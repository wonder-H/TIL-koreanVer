# TIL 2022-04-08

기존 복습 + 추가 공부

* * *

## CSS의 box-sizing

- 요소의 크기를 어떤 것을 기준으로 계산할지 지정하는 속성

> box-sizing의 속성값

```
content-box | border-box | initial | inherit
```

  1. content-box: 컨텐츠 영역(요소의 내용) 기준

<br>

  2. border-box: 테두리 기준
      - content + padding + border의 총합을 최종 값으로 적용
      - 총합을 기준으로 계산하므로 실제 랜더링되는 박스 내부의 값을 설정할 수 있어 편리함
      - margin은 박스 외부 여백이니 계산에 적용 안됨

<br>

  3. initial: 기본값

<br>

  4. inherit: 부모의 속성값을 상속받음

<br>

```html
//html
  <div class="content-box"></div>
  <div class="border-box"></div>

//css
<style>
  div {
    padding: 20px;
    border: 20px solid;
    width: 100px;
  }
  .content-box {
    box-sizing: content-box;
  }
  .border-box {
    box-sizing: border-box;
  }
</style>
```

> width를 100px로 지정했을 때 
  
  + content-box: 컨텐츠만 100px로 적용. 나머지 속성의 크기는 별도로 추가

        총 width값 = 180px(content 100px + padding좌/우20px씩 + border좌/우20px씩) 
  

  + boder-box: 요소의 실질적인 전체 크기를 100px로 맞춰서 적용.
      
        총 width값 = 100px (content 20px + padding좌/우20px + border좌우20px)

* * *

## overflow

- 내용이 요소의 크기 이상으로 넘치게 되었을 때, 어떻게 보여줄 것인지를 지정하는 속성

> overflow의 속성값

```
visible | hidden | scroll | auto
```
  1. visible: 넘친 내용 그대로 표현
  2. hidden: 넘친 내용 숨김
  3. scroll: 넘친 내용 자르고 스크롤바 생성
  4. auto: 넘친 내용이 있으면 잘라내고 스크롤바 생성

- visible로 설정된 요소 두 개를 연속으로 배치하면 내용이 요소 밖으로 빠져나와 그 다음 두 번째 요소의 내용과 겹쳐보일 수 있다
- hidden은 내용의 뒷 부분을 잘라버리지만, 의도치 않게 내용이 누락될 수 있기 때문에 조심해야한다

* * *

## position

- 요소를 실제 화면에서 어디에 위치하게 할 것인지 설정하는 속성
- html 요소를 보여주는 위치를 결정하는 핵심적 존재
- 요소를 어떤 기준, 어디에 배치시킬 것인지 표현
- 속성값 적용 후 추가로 top, right, left, bottom에 수치를 넣어 최종 위치를 결정(offset)
  
  > offset ?
  
    + 특정 위치를 먼저 기준으로 잡은 후, 그 기준에서부터 일정 수치만큼 이동시키는 것

<br>

> position의 속성값

```
static | relative |	absolute | fixed | sticky
```

  __1. static: 기본값. 기준 위치 설정안함__

   - 정적인 위치지정 방식
   - 위치 이동 안됨
   - 단순히 웹 페이지의 흐름에 맞춰 차례대로 요소를 배치
   - 모든 html요소의 초기 position값은 static임
   - 주로 이미 설정된 position의 값을 기본으로 바꾸기 위해 사용

<br> 

  __2. relative: 현 위치를 기준으로 상대 위치 지정__

   - 요소 자신이 static일 때 배치되는 곳이 기준점(자신의 원래 위치가 기준)
   - 상대적인 위치지정 방식(상대 요소 위치에 따라 자신의 위치를 재조정)
   - 일반적인 문서 흐름에 따라 배치해놓고 offset으로 위치이동을 시키는 개념(static처럼 배치시키고, 후에 이동!)
   - 때문에 요소가 원래 static일 때 배치되어야 하는 곳에 위치를 두고, 그 위치로부터 떨어지게끔 만든다
   - offset(위치이동) 후에는 다른 요소들에게 영향을 주지 않기 때문에 실제 페이지 레이아웃에서 relative가 적용된 요소가 차지하는 공간은 이 요소가 원래 static이었을 때와 같음
   - 직접적으로 움직이는 용도로 사용은 잘 안함
   - 주로 위치상의 부모로 설정하는 것이 목적(아래 자식 요소에서 absolute를 적용하기 위해)

<br> 

  __3. absolute: 부모 위치를 기준으로 절대 위치 지정__

   - 이름에 맞는 절대적인 위치지정 방식
   - 그러나 사실 화면에서 항상 절대적인 위치가 되는것은 아님...
   - 형제 요소들과의 위치를 무시하고 부모 위치만 기준으로 따지게 됨
   - absolute가 적용되기 위해서는 부모가 absolute, relative, fixed여야 함 
   - 요소가 속해있는 바로 위 부모를 기준으로 위치 설정
   - 만약 부모가 static이라면 조상까지(정확히는 static아닌 녀석을 찾을 때까지) 올라감
   - 만약 모든 상위 요소가 static이면 최상위인 body가 기준(0,0)으로 결정됨
   - 때문에 보통은 레이아웃 상으로 위에 위치한 요소를 relative를 이용해 부모요소로 만든 후, 이동시킬 요소에 absolute를 적용해 부모 위치로부터 떨어지는 용도로 사용
   - absolute 적용 시 다른 태그들이 이 속성이 있는 요소를 무시하게 됨
   - 페이지 레이아웃 상으로도 absolute가 적용된 요소에게 주는 공간이 없음
   - 태그들의 위치가 겹칠수 있음
   - 때문에 다른 요소가 이미 그 위치에 자리잡고 있어도 absolute인 요소는 옆으로 밀려나지 않고 이미 자리잡고 있는 요소의 앞/뒤쪽에 붙이는 것이 가능(레이어 개념) 
   - 덕분에 다른 요소들과 margin 겹침현상이 나타날 일이 없음(레이어가 다르니까!)
   - 앞/뒤 보여주는 조정은 추가로 z-index를 사용해야 가능
   - absolute로 적용하면 기존의 block요소가 inline요소로 되어 컨텐츠 영역만을 차지하게 되므로 width, height 설정해야 함.
   - 부모의 위치를 기준으로 하지만 실제 그 위치를 벗어나 어디든 갈 수 있음(화면 밖까지도...) 

<br> 

  __4. fixed:	뷰포트(브라우저 화면)를 기준으로 절대 위치 지정, 요소를 해당 위치에 고정__

   - 고정적인 위치지정 방식
   - absolute와 같이 문서의 흐름에서 배제되고 레이아웃 위에 할당되는 공간도 없어짐(다른 애들과 margin겹칠 일 없음!)
   - 무조건 뷰포트상의 초기 컨테이너 위(브라우저의 좌표)를 우선기준으로 위치값 설정
   - 단, 적용되는 요소의 조상 중 하나가 transform, perspective, filter 속성 중 어느 하나라도 none이 아니면 위치의 기준점은 뷰포트가 아닌 그 조상으로 적용된다(** perspective, filter의 경우 브라우저별로 결과가 다를 수 있음)
   - 그러나 보통은 뷰포트 화면만 따지게 되기 때문에 사실상 absolute보다 더 절대적인 기준으로 위치지정 가능
   - 때문에 웹페이지가 스크롤 되어도 상관없이 항상 같은 자리에 고정시킬 수 있음
   - 부모의 속성/위치에 큰 관계도 없으므로 항상 화면에서 절대적인 위치에서 존재하게 된다
   - fixed로 적용시 기존의 block요소도 inline요소로 되어 컨텐츠 영역만 차지하므로 width, height 설정해야 함.
   - 웹페이지 로딩을 느려지게 만드는 주 범인이 될 수 있음

<br> 

  __5. sticky: 지정된 위치에 뷰포트가 도달시, 요소가 그 위치에 붙여져 고정됨__

   - 상대적인 위치 지정(relative), 고정적인 위치 지정(fixed)을 합친 것
   - 때문에 relative처럼 문서의 흐름을 따라서 배치되고, 스크롤 등으로 어떤 액션이 발생해 위치로 지정했던 경계선을 지나면 fixed같은 효과를 적용 
   - 부모(부모가 아니면 그 조상까지)가 overflow가 hidden, scroll, auto또는 overlay속성이 있을 때 달라붙음
   - 만약 sticky로 달라붙은 부모/조상요소가 스크롤이 적용안되고, 정작 실제 스크롤이 되는 녀석(또다른 조상)이 따로 존재한다면 sticky속성은 적용되지 않게 되므로 주의.
   - top, right, bottom, left 중 적어도 한 위치를 경계선의 값(fixed가 적용될 구간)으로 지정해야 한다
   - 만약 값이 없다면 이녀석은 relative와 같은 효과를 보이게 됨

<br> 

> Position 속성에서 기타 주의사항

* 화면을 확대해서 텍스트가 크게 보이게 할 때 absolute나 fixed로 배치된 요소들이 실제 내용을 가릴 수 있으므로 UI/UX에 주의할 것

* fixed, sticky를 포함하는 스크롤 요소들은 실제 웹 성능과 접근성 문제를 만들어낼 수 있으므로 UI/UX를 고려해 주의하면서 사용할 것(문제가 생겼을 때 will-change: transform을 추가해 해결할 수도 있음)

* 위치 이동에서 요소들끼리 __마진겹침__ 현상이 일어날 수 있으므로 주의.

  > 마진겹침 ?

   + 상/하의 마진값이 어떤 상황에서 사라지는 현상
   + 자식태그의 마진값이 부모태그의 마진값보다 커지면 => 마진값 사라지면서 위치 수정됨
   + 마진겹침은 인접한 두 요소가 온전한 block일 때에 적용됨

  <br> 

  > 마진겹침 예외상황
  
  1. 마주친 요소들 중 어떤 요소가 position: absolute인 녀석은 예외
  2. 마주친 된 요소들 중 어떤 요소가 float: left/right(clear되지 않은 상태)인 녀석은 예외
  3. 마주친 요소들 중 어떤 요소가 display: inline인 녀석은 예외
  4. 마주친 요소들의 관계가 display: flex, 내부요소가 flexbox-item인 상태인 녀석들 예외
  5. 마주친 요소들의 관계가 display: grid, 내부요소가 grid-item인 상태인 녀석들 예외

  <br> 

* * *

## display

- 요소를 실제 화면에 어떻게 보여지게 할 것인지를 레이아웃을 설정하는 속성
- 기본값은 inline
- display 속성은 모든 요소에 적용 가능
- position속성과 함께 CSS의 레이아웃 구현을 일궈내는 핵심적인 속성
- display를 none으로 적용하면 그 요소는 position, float속성도 적용불가(-> 해당 요소가 랜더링으로 만들어지지 않으니까...)

> display의 속성값

```
none | inline | block | inline-block | flex | grid
```

  1. none: 요소를 렌더링하지 않음
      - 영역을 차지하지 않게됨(완전히 레이아웃상에서 사라진 존재가 됨)
      - visibility:hidden의 경우 존재는 하지만 화면 랜더링만 안한것(그 자리에 그 크기 그대로 있으나 그냥 안보여주는 것뿐...)  

<br> 

  2. inline: 요소를 inline속성으로 적용
       - 글자요소처럼 되는 것
       - 주변 요소들과 한 줄에서 같이 나열됨
       - 글자요소이기 때문에 width, height을 넣을 수 없음
       - margin은 위/아래쪽 적용불가
       - padding은 좌/우방향이 공간/시각적 여백이 모두 생기지만 상/하는 시각적으로 추가만 되고 실제 공간을 차지하지는 않게 적용됨

<br> 

  3. block: 요소를 block속성으로 적용
       - 상자요소처럼 되는 것
       - 상자요소이기 때문에 width, height, margin, paddin을 넣을 수 있음
       - 상자라서 가로 영역을 모두 차지하려고 함(block 요소의 특성)
       - 1줄당 1개만 배치되는 특성(주변 요소들과 같이 나열 불가)

<br> 

  4. inline-block: 요소 밖은 inline처럼, 내부는 block처럼 적용
       - 밖의 다른 요소들과의 관계는 inline요소인 녀석으로 처리됨
       - 밖의 요소들과는 한 줄에서 같이 나열 가능(inline특성)
       - 요소의 내부에서는 block처럼 동작
       - 줄바꿈 안됨(block특성)
       - width, height 지정 가능(block특성)

<br> 

  5. flex
      - 1차원 레이아웃
      - 지정된 요소는 container가 되고, 자식 요소들을 가로/세로 방향에 맞춰 배치할 수 있음
      - 자식 요소들의 크기가 다르거나, 반응형 디자인 제작에도 요소들을 잘 정렬되게 설정 가능
      - UI레이아웃 디자인에 최적화됨
      - 이전의 float속성보다 무한대급으로 좋음

<br>

  6. grid
      - 2차원 레이아웃
      - 행/열의 비율, 크기를 지정해 사용
      - row는 가로, column은 세로를 지정할 수 있음

<br>

* * *

> 참고자료
- mdn 및 구글의 힘으로 알게 된 많은 글들

<br>

*!* Display의 Flex와 Grid는 다뤄야 하는 내용의 양이 많으므로 다른 글에서 다시 정리할 예정